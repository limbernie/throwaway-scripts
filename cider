#!/bin/bash -
# Expand and print IPv4 address in CIDR notation to standard output
# Version 3.0
# Written by Bernard Lim <lim.yiok.kia@gmail.com>

AUTHOR="Bernard Lim <lim.yiok.kia@gmail.com>"
VERSION="3.0"
PROG=$(basename $0)

# default action: print range
ACTION=print_cidr

# fanciful output
b="\033[1m"  # bold
u="\033[4m"  # underline
o="\033[0m"  # off

# graceful death!
die() {
  echo "$PROG: $*" >&2
  exit 1
}

# shorter usage
short() {
  usage | sed 2q
  echo "See \`$PROG -h' for more information"
}

# usage
usage() {
cat<<EOF
Usage: $PROG [OPTION] [ADDRESS]...
Expand and print ADDRESS in CIDR notation to standard output

$(echo -e ${b}Options${o})
  -c TYPE       Quick conversion for TYPE
  -e            Expand and print ADDRESS line by line
  -h            Display this help and exit
  -v            Print version information and exit

Conversion TYPE can be:
  1   address to number
  2   number to address
  3   address to hexadecimal
  4   hexadecimal to address
  5   netmask bits to address
  6   netmask address to bits

Without any options, $PROG will only print the range of
ADDRESS, i.e. starting and ending IP address as follows:

  a.b.c.d - w.x.y.z    where a, b, c, d, w, x, y and z
                       are integers from 0 to 255

Note that using option \`-e' may take a longer time depending on
the netmask because $PROG is printing every single IP address in
the range.

When ADDRESS is -, read standard input. This is useful if you $(echo -ne ${b}cat${o})(1)
a list of addresses to $PROG for fast expansion.

$(echo -e ${b}Examples${o})
  $PROG 10.10.10.10/10      # Expand and print range
  $PROG -e 10.10.10.10/10   # Expand and print all IP address in range
  $PROG -c1 10.10.10.10     # Convert IP address to number
  $PROG -c2 168430090       # Convert number to IP address
  $PROG -c3 10.10.10.10     # Convert IP address to hexadecimal
  $PROG -c4 21              # Convert netmask bits to netmask address

Report $PROG bugs to $AUTHOR
This software is distributed in the hope that it will be
useful but without any warranty. It is provided "as is".
EOF
}

###############################################################################
#                                                                             #
#                          INPUT VALIDATION (BASH)                            #
#                                                                             #
###############################################################################

# CIDR validation
validate_cidr() {
  # sanity check
  if [ -z "$1" ]; then
    short; exit 1
  fi

  # syntax check
  local syntax="^([0-9]{1,3}\.){3}([0-9]{1,3})\/[0-9]{1,2}$"
  if grep -Ev "$syntax" >/dev/null <<<"$1"; then
    die "invalid IP4 address or netmask"
  fi

  # is the IP address valid?
  OLD_IFS="$IFS"
  IFS=./ read -r a b c d e <<<"$1"; IFS="$OLD_IFS"
  if (( $a > 255 || $b > 255 || $c > 255 || $d > 255 )); then
    die "invalid IPv4 address"
  fi

  # is the netmask valid?
  if (( $((10#$e)) > 32 )); then
    die "invalid netmask"
  fi
}

# IP address validation
validate_ip() {
  # sanity check
  if [ -z "$1" ]; then
    short; exit 1
  fi

  # syntax check
  local syntax="^([0-9]{1,3}\.){3}([0-9]{1,3})$"
  if grep -Ev "$syntax" >/dev/null <<<"$1"; then
    die "invalid IP address"
  fi

  # is the IP address valid?
  OLD_IFS="$IFS"
  IFS=. read -r a b c d <<<"$1"; IFS="$OLD_IFS"
  if (( $a > 255 || $b > 255 || $c > 255 || $d > 255 )); then
    die "invalid IPv4 address"
  fi
}

# netmask validation
validate_nm() {
  # sanity check
  if [ -z "$1" ]; then
    short; exit 1
  fi

  # syntax check
  local syntax="^[0-9]{1,2}$"
  if grep -Ev "$syntax" >/dev/null <<<"$1"; then
    die "invalid netmask"
  fi

  # is the netmask valid?
  if (( $((10#$1)) > 32 )); then
    dike "invalid netmask"
  fi
}

# number validation
validate_num() {
  # sanity check
  if [ -z "$1" ]; then
    short; exit 1
  fi

  # syntax check
  local syntax="^[0-9]+$"
  if grep -Ev "$syntax" >/dev/null <<<"$1"; then
    die "invalid IPv4 address"
  fi

  # is the IP address valid?
  if (( "$1" > 0xffffffff )); then
    die "invalid IPv4 address"
  fi
}

###############################################################################
#                                                                             #
#                            CONVERSIONS (BASH)                               #
#                                                                             #
###############################################################################

# convert netmask bits to number
bit2num_() {
  input=$1
  validate_nm $input

  let bits=$input
  let nmask=0
  for ((b=0; b<bits; b++)); do
    nmask=$((nmask | 1 << (31 - b)))
  done
  echo $nmask
}

# convert netmask bits to address
bit2addr_() {
  input=$1
  validate_nm $input

  let bit=$input
  echo $(num2quad_ $(bit2num_ $bit))
}

# convert number to quad-dotted notation
num2quad_() {
  input=$1
  validate_num $input

  let num=$input
  for ((o=0; o<4; o++)); do
    a[$o]=$((num >> (8 * (3 - o)) & 0xff))
  done
  printf "%d.%d.%d.%d\n" ${a[0]} ${a[1]} ${a[2]} ${a[3]}
}

# convert quad-dotted notation to hexadecimal
quad2hex_() {
  input=$1
  validate_ip $input

  printf "0x%X\n" $(quad2num_ $input)
}

# convert quad-dotted notation to number
quad2num_() {
  input=$1
  validate_ip $input

  OLD_IFS="$IFS"
  IFS=. read -a octet <<<"$input"; IFS="$OLD_IFS"
  let num=0
  for ((o=0; o<4; o++)); do
    num=$((num | octet[o] << (8 * (3 - o))))
  done
  echo $num
}

###############################################################################
#                                                                             #
#                          EXPAND RANGE (BASH)                                #
#                                                                             #
###############################################################################

# expand CIDR range
expand_cidr_() {
  input=$1
  validate_cidr $input

  # split input
  OLD_IFS="$IFS"
  IFS=./ read -r o1 o2 o3 o4 nm <<<"$input"; IFS="$OLD_IFS"

  let  wc=$((32 - nm)) # cisco wildcard bits
  let   o=$((wc / 8))  # no. of octets
  let msb=$((wc % 8))  # most significant bits

  n=$((2**msb-1))
  quad="%d.%d.%d.%d"

  case $o in
    0)
      o4=$((o4 & $((255-n))))
      for ((i=0; i<=$n; i++)); do
        printf "$quad\n" $o1 $o2 $o3 $((o4+i))
      done
      ;;
    1)
      o3=$((o3 & $((255-n))))
      for ((i=0; i<=$n; i++)); do
        for ((j=0; j<=255; j++)); do
          printf "$quad\n" $o1 $o2 $((o3+i)) $j
        done
      done
      ;;
    2)
      o2=$((o2 & $((255-n))))
      for ((i=0; i<=$n; i++)); do
        for ((j=0; j<=255; j++)); do
          for ((k=0; k<=255; k++)); do
            printf "$quad\n" $o1 $((o2+i)) $j $k
          done
        done
      done
      ;;
    3)
      o1=$((o1 & $((255-n))))
      for ((i=0; i<=$n; i++)); do
        for ((j=0; j<=255; j++)); do
          for ((k=0; k<=255; k++)); do
            for ((l=0; l<=255; l++)); do
              printf "$quad\n" $((o1+i)) $j $k $l
            done
          done
        done
      done
      ;;
    4)
      for ((i=0; i<=255; i++)); do
        for ((j=0; j<=255; j++)); do
          for ((k=0; k<=255; k++)); do
            for ((l=0; l<=255; l++)); do
              printf "$quad\n" $i $j $k $l
            done
          done
        done
      done
      ;;
  esac
}

###############################################################################
#                                                                             #
#                           PRINT RANGE (BASH)                                #
#                                                                             #
###############################################################################

# print CIDR range
print_cidr_() {
  input=$1
  validate_cidr $input

  # split input
  OLD_IFS="$IFS"
  IFS=/ read -r ip nm <<<"$1"; IFS="$OLD_IFS"

  lo=$(($(quad2num_ $ip) & $(bit2num_ $nm)))
  hi=$((0xffffffff - $(bit2num_ $nm) + $lo))

  printf "%s - %s\n" $(num2quad_ $lo) $(num2quad_ $hi)
}

###############################################################################
#                                                                             #
#                               ACTIONS                                       #
#                                                                             #
###############################################################################

# quad2num() {}
# num2quad() {}
# quad2hex() {}
# hex2quad() {}
# bit2addr() {}
# addr2bit() {}

# expand CIDR range
expand_cidr() {
  if [[ "$1" == "-" ]]; then
    _awk "expand_cidr" -
  else
    _awk "expand_cidr" <<<"$*"
  fi
}

# print CIDR range
print_cidr() {
  if [[ "$1" == "-" ]]; then
    _awk "print_cidr" -
  else
    _awk "print_cidr" <<<"$*"
  fi
}

###############################################################################
#                                                                             #
#                           FUNCTION CHOOSER                                  #
#                                                                             #
###############################################################################

# functions in awk (fast)
_awk() {
  awk -F"[./]" -v "prog=$PROG" -v "f=$1" '
    function bit2num(bits)
    {
      num = 0;
      for (b = 0; b < bits; b++)
        num = or(num, lshift(1, (31 - b)));
      return num
    }
    function num2quad(num)
    {
      for (o = 0; o < 4; o++)
        a[o] = and(rshift(num, 8 * (3 - o)), 0xff)
      return a[0]"."a[1]"."a[2]"."a[3]
    }
    function quad2num(quad)
    {
      split(quad, octets, ".")
      num = 0;
      for (o = 0; o < 4; o++)
        num = or(num, lshift(octets[o+1], 8 * (3 - o)));
      return num
    }
    function die(err)
    {
      print prog ": " err > "/dev/stderr"
      next
    }
    function validate_cidr(a)
    {
      if (a !~ /^([0-9]{1,3}\.){3}([0-9]{1,3})\/[0-9]{1,2}$/)
        die("invalid IPv4 address or netmask")
    }
    function validate_ip(ip)
    {
      split(ip, quad, ".")
      if (quad[1] < 0 || quad[1] > 255) die("invalid IPv4 address")
      if (quad[2] < 0 || quad[2] > 255) die("invalid IPv4 address")
      if (quad[3] < 0 || quad[3] > 255) die("invalid IPv4 address")
      if (quad[4] < 0 || quad[4] > 255) die("invalid IPv4 address")
    }
    function validate_nm(nm)
    {
      if (nm < 0 || nm > 32) die("invalid netmask")
    }
    function validate_num(num)
    {
      if (num < 0 || num > 0xffffffff) die("invalid IPv4 address")
    }
    function expand_cidr()
    {
      validate_cidr($0)
      ip = $1"."$2"."$3"."$4; validate_ip(ip)
      nm=$5; validate_nm(nm)
      lo = and(quad2num(ip), bit2num(nm))
      hi = 0xffffffff - bit2num(nm) + lo
      for (i=lo; i<=hi; i++) printf "%s\n", num2quad(i)
    }
    function print_cidr()
    {
      validate_cidr($0)
      ip = $1"."$2"."$3"."$4; validate_ip(ip)
      nm=$5; validate_nm(nm)
      lo = and(quad2num(ip), bit2num(nm))
      hi = 0xffffffff - bit2num(nm) + lo
      printf "%s - %s\n", num2quad(lo), num2quad(hi)
    }
    /* function chooser */
    {
      switch (f) {
        case "print_cidr": print_cidr(); break
        case "expand_cidr": expand_cidr(); break
        default: die("unknown function"); break
      }
    }' $2
}

###############################################################################
#                                                                             #
#                                 MAIN                                        #
#                                                                             #
###############################################################################

# parse short options
OPTIND=1
while getopts ":c:ehv" opt; do
  shift $((OPTIND-1))
  case $opt in
    c)
      case $OPTARG in
        1) ACTION=quad2num_;;
        2) ACTION=num2quad_;;
        3) ACTION=quad2hex_;;
        4) ACTION=hex2quad_;;
        5) ACTION=bit2addr_;;
        6) ACTION=addr2bit_;;
        *) die "invalid option argument: $OPTARG";;
      esac
      ;;
    e)
      ACTION=expand_cidr
      ;;
    h)
      if [ $# -eq 0 ]; then
        usage; exit 0
      else
        short; exit 1
      fi
      ;;
    v)
      if [ $# -eq 0 ]; then
        echo "$PROG $VERSION"
        echo "Written by $AUTHOR"
        exit 0
      else
        short; exit 1
      fi
      ;;
   \?) die "invalid option: -$OPTARG";;
  esac
done

# main
if [ $# -eq 0 ]; then
  # empty arguments
  short
  exit 1
elif [[ "$1" == "-" ]]; then
  # read from stdin
  $ACTION -
else
  # multiple arguments
  for input in $@; do
    $ACTION $input
  done
fi
