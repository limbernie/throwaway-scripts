#!/bin/bash -
# Print a country's IP blocks in CIDR notation to standard output
# Version 3.0
# Written by Bernard Lim <bernard.lim@sands.com>

AUTHOR="Bernard Lim <lim.yiok.kia@gmail.com>"
VERSION="3.0"
PROG=$(basename $0)

# default: CC to IP blocks
ACTION=cc2ip

# if GNU parallel is not installed
PARALLEL="xargs -n1 -P${MAX:=64} -I{}"

# fanciful output
b="\033[1m"  # bold
u="\033[4m"  # underline
o="\033[0m"  # off

# graceful death!
die() {
  echo "$PROG: $*" >&2
  exit 1
}

# shorter usage
short() {
  usage | sed 2q
  echo "See \`$PROG -h' for more information"
}

# usage
usage() {
cat <<EOF
Usage: $PROG [OPTION] [CC]... (2-letter country code)
Print CC's IP blocks in CIDR notation to standard output

$(echo -e ${b}Options${o})
  -a            Print ASN's IP blocks and exit
  -c            Print CC's ASNs and exit
  -h            Display this help and exit
  -p n          Run n processes in parallel (default n=64)
  -v            Show version information and exit

$PROG uses ISO 3166-1 alpha-2 codes to represent country.
They are 2-letter country codes used widely to represent
countries, dependent territories and special areas of
geographical interest.

$(echo -e ${b}Examples${o})
  $PROG SG          # Print Singapore's IP blocks (fast)
  $PROG US          # Print United States' IP blocks (long)
  $PROG -p 100 SG   # Same as above but run 100 processes in parallel
  $PROG -a AS668    # Print IP blocks originating from AS668
  $PROG -c SG       # Print ASNs originating from SG

Report $PROG bugs to $AUTHOR
This software is distributed in the hope that it will be
useful but without any warranty. It is provided "as is".
EOF
}

# return IP prefixes from ASN
asn2ip() {
  local asn=$1; validate_asn $asn
  local command=!g
  local server=whois.radb.net

  if [[ -z "$asn" || "$asn" == "-" ]]; then
    cat -
  else
    cat <<<"$asn"
  fi | ($PARALLEL whois -h $server "$command{}" 2>/dev/null | \
      grep -Ev '^[a-zA-Z]' | tr -d '\n' | sed -r 's/(\/[0-9]{1,2})/\1\n/g' | \
        sed '/^$/d' | tr -d ' ') | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4 | \
          uniq -c | awk '{ print $NF }'
}

# return ASN from CC
cc2asn() {
  local cc=$(tr 'a-z' 'A-Z' <<<$1); validate_cc $cc
  local ua="Mozilla/5.0"
  local url="http://bgp.he.net/country"

  if [[ -z "$cc" || "$cc" == "-" ]]; then
    cat -
  else
    cat <<<"$cc"
  fi | ($PARALLEL curl -s -A $ua $url/{} | grep -Eo 'AS[0-9]+') | uniq -c | awk '{ print $NF }'
}

# return IP from CC
cc2ip() {
  local cc=$1; validate_cc $cc

  if [[ -z "$cc" || "$cc" == "-" ]]; then
    cc2asn | asn2ip
  else
    cc2asn <<<"$cc" | asn2ip
  fi
}

# validate ASN
validate_asn() {
  local asn=$1

  # format check
  if grep -Ev '^(-?|[aA][sS][0-9]+)$' <<<"$asn" > /dev/null; then
    die "invalid ASN format"
  fi
}

# validate CC
validate_cc() {
  local cc=$1

  # format check
  if grep -Ev '^(-?|[a-zA-Z]{2})$' <<<"$cc" >/dev/null; then
    die "invalid country code"
  fi
}

# Check for empty arguments
if [ $# -eq 0 ]; then
  short
  exit 1
fi

# Parse short options
OPTIND=1
while getopts ":achp:v" opt; do
  shift $((OPTIND-1))
  case $opt in
  a)
    if [[ "$LASTOPT" == "$opt" ]]; then short; exit 1; fi
    if [ $# -ge 1 ]; then
      ACTION=asn2ip
    else
      short; exit 1
    fi
    LASTOPT=$opt
    ;;
  c)
    if [[ "$LASTOPT" == "$opt" ]]; then short; exit 1; fi
    if [ $# -ge 1 ]; then
      ACTION=cc2asn
    else
      short; exit 1
    fi
    LASTOPT=$opt
    ;;
  h)
    if [ $# -eq 0 ]; then
      usage
      exit 0
    else
      short; exit 1
    fi
    ;;
  p)
    if [[ "$LASTOPT" == "$opt" ]]; then short; exit 1; fi
    if [ $# -ge 1 ]; then
      if grep -Ev '^[0-9]+$' &>/dev/null <<<"$OPTARG"; then
        short; exit 1
      fi
      MAX=$((10#$OPTARG))
    else
      short; exit 1
    fi
    LASTOPT=$opt
    ;;
  v)
    if [ $# -eq 0 ]; then
      echo "$PROG $VERSION"
      echo "Written by $AUTHOR"
      exit 0
    else
      short; exit 1
    fi
    ;;
  :)
    die "-$OPTARG requires an argument"
    ;;
  \?)
    short; exit 1
    ;;
  esac
done;

# main
# is GNU parallel installed?
if which parallel &>/dev/null; then
  PARALLEL="parallel -j+${MAX:=64}"
fi

if [[ -z "$1" || "$1" == "-" ]]; then
  $ACTION -
else
  for i in $*; do $ACTION $i; done
fi
